
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.dynatrace.AWSClassicLoadBalancer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder.EndpointConfiguration;
import com.amazonaws.services.cloudwatch.AmazonCloudWatch;
import com.amazonaws.services.cloudwatch.AmazonCloudWatchClientBuilder;
import com.amazonaws.services.cloudwatch.model.Datapoint;
import com.amazonaws.services.cloudwatch.model.Dimension;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsRequest;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsResult;
import com.dynatrace.AWSClassicLoadBalancer.Constants.IConstants;
import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Status;
import com.dynatrace.diagnostics.pdk.TaskEnvironment;


public class Plugin implements Monitor {

	private static final Logger log = Logger.getLogger(Plugin.class.getName());

	private List<String> m_oLBMetrics = new ArrayList<String>();
	
	/*
	 * We will push all aggregations to AppMon
	 * However, remember that not all metrics will be useful.
	 * See: http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html#load-balancer-metric-dimensions-alb
	 */
	private List<String> m_oAggregationList = new ArrayList<String>();
	
	/**
	 * Initializes the Plugin. This method is called in the following cases:
	 * <ul>
	 * <li>before <tt>execute</tt> is called the first time for this
	 * scheduled Plugin</li>
	 * <li>before the next <tt>execute</tt> if <tt>teardown</tt> was called
	 * after the last execution</li>
	 * </ul>
	 * <p>
	 * If the returned status is <tt>null</tt> or the status code is a
	 * non-success code then {@link Plugin#teardown() teardown()} will be called
	 * next.
	 * <p>
	 * Resources like sockets or files can be opened in this method.
	 * @param env
	 *            the configured <tt>MonitorEnvironment</tt> for this Plugin;
	 *            contains subscribed measures, but <b>measurements will be
	 *            discarded</b>
	 * @see Plugin#teardown()
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status setup(MonitorEnvironment env) throws Exception
	{	
        m_oLBMetrics.add("BackendConnectionErrors");
        m_oLBMetrics.add("HealthyHostCount");
        m_oLBMetrics.add("HTTPCode_Backend_2XX");
        m_oLBMetrics.add("HTTPCode_Backend_3XX");
        m_oLBMetrics.add("HTTPCode_Backend_4XX");
        m_oLBMetrics.add("HTTPCode_Backend_5XX");
        m_oLBMetrics.add("HTTPCode_ELB_4XX");
        m_oLBMetrics.add("HTTPCode_ELB_5XX");
        m_oLBMetrics.add("Latency");
        m_oLBMetrics.add("RequestCount");
        m_oLBMetrics.add("SpilloverCount");
        m_oLBMetrics.add("SurgeQueueLength");
        m_oLBMetrics.add("UnHealthyHostCount");
        
        
        m_oAggregationList.add(IConstants.AGGREGATION_MINIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_AVERAGE);
        m_oAggregationList.add(IConstants.AGGREGATION_MAXIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_SUM);
		m_oAggregationList.add(IConstants.AGGREGATION_SAMPLE_COUNT);
        
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Executes the Monitor Plugin to retrieve subscribed measures and store
	 * measurements.
	 *
	 * <p>
	 * This method is called at the scheduled intervals. If the Plugin execution
	 * takes longer than the schedule interval, subsequent calls to
	 * {@link #execute(MonitorEnvironment)} will be skipped until this method
	 * returns. After the execution duration exceeds the schedule timeout,
	 * {@link TaskEnvironment#isStopped()} will return <tt>true</tt>. In this
	 * case execution should be stopped as soon as possible. If the Plugin
	 * ignores {@link TaskEnvironment#isStopped()} or fails to stop execution in
	 * a reasonable timeframe, the execution thread will be stopped ungracefully
	 * which might lead to resource leaks!
	 *
	 * @param env
	 *            a <tt>MonitorEnvironment</tt> object that contains the
	 *            Plugin configuration and subscribed measures. These
	*            <tt>MonitorMeasure</tt>s can be used to store measurements.
	 * @return a <tt>Status</tt> object that describes the result of the
	 *         method call
	 */
	@Override
	public Status execute(MonitorEnvironment env) throws Exception
	{	
		String strAccessKey = env.getConfigString(IConstants.ACCESS_KEY);
		String strSecretAccessKey = env.getConfigPassword(IConstants.SECRET_KEY);
		String strAWSRegion = env.getConfigString(IConstants.AWS_REGION);
		String strLoadBalancerName = env.getConfigString(IConstants.LOAD_BALANCER_NAME);
		
		/*
		 * Possible Values
		 * "1 Minute" | "5 Minutes" | "10 Minutes" | "15 Minutes" | "30 Minutes" | "1 Hour"
		 */
		String strDataGranularity = env.getConfigString(IConstants.DATA_GRANULARITY);
		
		//TODO - Error Checking
		if (strAccessKey == null | strAccessKey.isEmpty())
		{
			log.severe("Missing Access Key. Please configure monitor correctly.");
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem);
		}
		if (strSecretAccessKey == null | strSecretAccessKey.isEmpty()) log.severe("Missing Secret Access Key. Please configure monitor correctly.");
		if (strAWSRegion == null | strAWSRegion.isEmpty())
		{
			log.severe("Missing AWS Region. Defaulting to eu-west-2. Please configure monitor correctly.");
			strAWSRegion = "eu-west-2";
		}
		if (strLoadBalancerName == null | strLoadBalancerName.isEmpty()) log.severe("Missing Load Balancer Name. Please configure monitor correctly.");
		
		BasicAWSCredentials oCredentials = new BasicAWSCredentials(strAccessKey, strSecretAccessKey);
        AWSStaticCredentialsProvider oProvider = new AWSStaticCredentialsProvider(oCredentials);

        String strEndpoint = "https://monitoring." + strAWSRegion + ".amazonaws.com"; // monitoring.eu-west-2.amazonaws.com
        
        log.fine("[DEBUG] Endpoint: " + strEndpoint);
        
        EndpointConfiguration oEndpointConfig = new EndpointConfiguration(strEndpoint, strAWSRegion);

        AmazonCloudWatch oClient = AmazonCloudWatchClientBuilder.standard().withCredentials(oProvider).withEndpointConfiguration(oEndpointConfig).build();
        
        List<GetMetricStatisticsResult> oResultList = new ArrayList<GetMetricStatisticsResult>();

        // Get LB Metric Results from AWS
        for(String strMetric : m_oLBMetrics)
        {
        	log.fine("[DEBUG] LB Name: " + strLoadBalancerName + " - Metric: " + strMetric);
        	oResultList.add(getLBMetricResult(oClient,strLoadBalancerName, strMetric, strDataGranularity));
        }
        
        log.fine("[DEBUG] Result List Size: " + oResultList.size());
        
        // Save the results to DT
        saveResults(oResultList, env);
        
		return new Status(Status.StatusCode.Success);
	}

	/**
	 * Shuts the Plugin down and frees resources. This method is called in the
	 * following cases:
	 * <ul>
	 * <li>the <tt>setup</tt> method failed</li>
	 * <li>the Plugin configuration has changed</li>
	 * <li>the execution duration of the Plugin exceeded the schedule timeout</li>
	 * <li>the schedule associated with this Plugin was removed</li>
	 * </ul>
	 *
	 * <p>
	 * The Plugin methods <tt>setup</tt>, <tt>execute</tt> and
	 * <tt>teardown</tt> are called on different threads, but they are called
	 * sequentially. This means that the execution of these methods does not
	 * overlap, they are executed one after the other.
	 *
	 * <p>
	 * Examples:
	 * <ul>
	 * <li><tt>setup</tt> (failed) -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, configuration changes, <tt>execute</tt>
	 * ends -&gt; <tt>teardown</tt><br>
	 * on next schedule interval: <tt>setup</tt> -&gt; <tt>execute</tt> ...</li>
	 * <li><tt>execute</tt> starts, execution duration timeout,
	 * <tt>execute</tt> stops -&gt; <tt>teardown</tt></li>
	 * <li><tt>execute</tt> starts, <tt>execute</tt> ends, schedule is
	 * removed -&gt; <tt>teardown</tt></li>
	 * </ul>
	 * Failed means that either an unhandled exception is thrown or the status
	 * returned by the method contains a non-success code.
	 *
	 *
	 * <p>
	 * All by the Plugin allocated resources should be freed in this method.
	 * Examples are opened sockets or files.
	 *
	 * @see Monitor#setup(MonitorEnvironment)
	 */	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
		// TODO
	}
	 
	//********************
	// PRIVATE METHODS
	//********************
	private GetMetricStatisticsResult getLBMetricResult(AmazonCloudWatch oClient, String strLoadBalancerName, String strMetricName, String strDataGranularity)
	{
		//TODO - There's an easier way to say one hour behind etc.
		//TODO - Make this dynamic
		Date endTime = new Date();
		int dataGranularity = calculateDataGranularity(strDataGranularity);
		//int oneHour = 60 * 60 * 1000;
		Date startTime = new Date(endTime.getTime() - dataGranularity);
	
	    GetMetricStatisticsRequest oMetricRequest = new GetMetricStatisticsRequest()
	            .withStartTime(startTime)
	            .withNamespace(IConstants.AWS_NAMESPACE)
	            .withPeriod(dataGranularity)
	            .withDimensions(new Dimension().withName(IConstants.DIMENSION_NAME).withValue(strLoadBalancerName))
	            .withMetricName(strMetricName)
	            .withStatistics(m_oAggregationList)
	            .withEndTime(endTime);
	    
	    GetMetricStatisticsResult oResult = null;
	    try
	    {
	    	oResult = oClient.getMetricStatistics(oMetricRequest);
	    }
	    catch (Exception e)
	    {
	    	log.severe("Error getting metrics from AWS. Returning null. " + e.getMessage());
	    }
	    
	    return oResult;
	}
	
	/*
	 * Calculate how far back in time we go to grab metrics. Users should ensure they make this match the
	 * monitor execution schedule.
	 * For example, if we run the monitor every 5 mins, this *must* be set to 5 mins.
	 * Otherwise you could run the monitor every 5 minutes and yet pull back the last hours statistics.
	 * This would lead to very strange results.
	 */
	private int calculateDataGranularity(String strDataGranularity)
	{
		//TODO - Error Checking
		if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1MIN))
		{
			// Do 1 min TODO
			log.info("1min granularity");
			return 60 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_5MINS))
		{
			// Do 5 mins TODO
			log.info("5mins granularity");
			return 60 * 5 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_10MINS))
		{
			// Do 10 mins TODO
			log.info("10 mins granularity");
			return 60 * 10 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_15MINS))
		{
			// Do 15 mins TODO
			log.info("15 mins granularity");
			return 60 * 15 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_30MINS))
		{
			// Do 30 mins TODO
			log.info("30 mins granularity");
			return 60 * 30 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1HOUR))
		{
			// Do 1 hour TODO
			log.info("1 hour granularity");
			return 60 * 60 * 1000;
		}
		else
		{
			log.info("Got a strange data granularity. This should never happen. Return 60.");
			return 60;
		}
	}
	
	private void saveResults(List<GetMetricStatisticsResult> oResultList, MonitorEnvironment oEnvironment)
	{
		// For each potentially subscribed measure, get the actual measure from the environment
		for (String strMeasureName : m_oLBMetrics)
		{
			Collection<MonitorMeasure> monitorMeasures = oEnvironment.getMonitorMeasures(IConstants.MEASURE_GROUP_NAME, strMeasureName);
			log.fine("Monitor measures size for: " + strMeasureName + " - " + monitorMeasures.size()); // Should always be 1.
			
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures)
			{
				List<Datapoint> oResultDatapoints = getResultMetricDatapoints(strMeasureName, oResultList);
				
				log.fine("oResultDatapoints Size: " + oResultDatapoints.size()); // Need to make sure this is always 1.
				
				//TODO - Move this repeated logic into separate method
				// For each target aggregation, push the data into DT
				for (String strAggregation : m_oAggregationList)
				{
					MonitorMeasure oDynamicMeasure = oEnvironment.createDynamicMeasure(subscribedMonitorMeasure, "Aggregation", strAggregation);
					
					if (strAggregation.equals(IConstants.AGGREGATION_MINIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMinimum();
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_AVERAGE))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getAverage();
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_MAXIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMaximum();
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSum();
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SAMPLE_COUNT))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSampleCount();
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else
					{
						log.info("Found something else.. Should never happen");
					}	
				} // End for each aggregation list.
			} // End for each monitor.
		} // End for each measure name.
	}
		
	/*  Helper Method 
	 *  Find the AWS GetMetricStatisticsResult which matches the input String
	 *  and return it's datapoints.
	 *  eg. datapoints which matches "RequestCount"
	 */
	private List<Datapoint> getResultMetricDatapoints(String strMeasureName, List<GetMetricStatisticsResult> oResultList)
	{
		for (GetMetricStatisticsResult oTmpResult : oResultList)
		{
			if (oTmpResult.getLabel().equals(strMeasureName)) return oTmpResult.getDatapoints();
		}
		
		return new ArrayList<Datapoint>();
	}
	 
}
