
 /**
  * This template file was generated by Dynatrace client.
  * The Dynatrace community portal can be found here: http://community.dynatrace.com/
  * For information how to publish a plugin please visit https://community.dynatrace.com/community/display/DL/How+to+add+a+new+plugin/
  **/ 

package com.dynatrace.AWSClassicLoadBalancer;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import com.amazonaws.auth.AWSStaticCredentialsProvider;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.client.builder.AwsClientBuilder.EndpointConfiguration;
import com.amazonaws.services.cloudwatch.AmazonCloudWatch;
import com.amazonaws.services.cloudwatch.AmazonCloudWatchClientBuilder;
import com.amazonaws.services.cloudwatch.model.Datapoint;
import com.amazonaws.services.cloudwatch.model.Dimension;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsRequest;
import com.amazonaws.services.cloudwatch.model.GetMetricStatisticsResult;
import com.dynatrace.AWSClassicLoadBalancer.Constants.IConstants;
import com.dynatrace.diagnostics.pdk.Monitor;
import com.dynatrace.diagnostics.pdk.MonitorEnvironment;
import com.dynatrace.diagnostics.pdk.MonitorMeasure;
import com.dynatrace.diagnostics.pdk.Status;


public class Plugin implements Monitor
{
	private static final Logger log = Logger.getLogger(Plugin.class.getName());

	/* Hold the list of possible AWS metrics.
	 * See: http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html#loadbalancing-metrics-clb
	 */
	private List<String> m_oLBMetrics = new ArrayList<String>();
	
	/*
	 * We will push all aggregations to AppMon
	 * However, remember that not all metrics will be useful.
	 * See: http://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html#load-balancer-metric-dimensions-alb
	 */
	private List<String> m_oAggregationList = new ArrayList<String>();
	
	@Override
	public Status setup(MonitorEnvironment env) throws Exception
	{	
        m_oLBMetrics.add("BackendConnectionErrors");
        m_oLBMetrics.add("HealthyHostCount");
        m_oLBMetrics.add("HTTPCode_Backend_2XX");
        m_oLBMetrics.add("HTTPCode_Backend_3XX");
        m_oLBMetrics.add("HTTPCode_Backend_4XX");
        m_oLBMetrics.add("HTTPCode_Backend_5XX");
        m_oLBMetrics.add("HTTPCode_ELB_4XX");
        m_oLBMetrics.add("HTTPCode_ELB_5XX");
        m_oLBMetrics.add("Latency");
        m_oLBMetrics.add("RequestCount");
        m_oLBMetrics.add("SpilloverCount");
        m_oLBMetrics.add("SurgeQueueLength");
        m_oLBMetrics.add("UnHealthyHostCount");
        
        
        m_oAggregationList.add(IConstants.AGGREGATION_MINIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_AVERAGE);
        m_oAggregationList.add(IConstants.AGGREGATION_MAXIMUM);
        m_oAggregationList.add(IConstants.AGGREGATION_SUM);
		m_oAggregationList.add(IConstants.AGGREGATION_SAMPLE_COUNT);
        
		return new Status(Status.StatusCode.Success);
	}

	@Override
	public Status execute(MonitorEnvironment env) throws Exception
	{	
		String strAccessKey = env.getConfigString(IConstants.ACCESS_KEY);
		String strSecretAccessKey = env.getConfigPassword(IConstants.SECRET_KEY);
		String strAWSRegion = env.getConfigString(IConstants.AWS_REGION);
		String strLoadBalancerName = env.getConfigString(IConstants.LOAD_BALANCER_NAME);
		
		/*
		 * Possible Values
		 * "1 Minute" | "5 Minutes" | "10 Minutes" | "15 Minutes" | "30 Minutes" | "1 Hour"
		 */
		String strDataGranularity = env.getConfigString(IConstants.DATA_GRANULARITY);
		
		if (strAccessKey == null | strAccessKey.isEmpty())
		{
			log.severe("Missing Access Key. Please configure monitor correctly.");
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem);
		}
		if (strSecretAccessKey == null | strSecretAccessKey.isEmpty()) log.severe("Missing Secret Access Key. Please configure monitor correctly.");
		if (strAWSRegion == null | strAWSRegion.isEmpty())
		{
			log.severe("Missing AWS Region. Defaulting to eu-west-2. Please configure monitor correctly.");
			strAWSRegion = "eu-west-2";
		}
		if (strLoadBalancerName == null | strLoadBalancerName.isEmpty())
		{
			log.severe("Missing Load Balancer Name. Please configure monitor correctly.");
			return new Status(Status.StatusCode.ErrorInternalConfigurationProblem);
		}
		
		BasicAWSCredentials oCredentials = new BasicAWSCredentials(strAccessKey, strSecretAccessKey);
        AWSStaticCredentialsProvider oProvider = new AWSStaticCredentialsProvider(oCredentials);

        String strEndpoint = "https://monitoring." + strAWSRegion + ".amazonaws.com"; // monitoring.eu-west-2.amazonaws.com
        
        log.fine("[DEBUG] Endpoint: " + strEndpoint);
        
        EndpointConfiguration oEndpointConfig = new EndpointConfiguration(strEndpoint, strAWSRegion);

        AmazonCloudWatch oClient = AmazonCloudWatchClientBuilder.standard().withCredentials(oProvider).withEndpointConfiguration(oEndpointConfig).build();
        
        List<GetMetricStatisticsResult> oResultList = new ArrayList<GetMetricStatisticsResult>();

        // Get LB Metric Results from AWS. This is where the external call is made out to AWS.
        for(String strMetric : m_oLBMetrics)
        {
        	log.fine("[DEBUG] LB Name: " + strLoadBalancerName + " - Metric: " + strMetric);
        	oResultList.add(getLBMetricResult(oClient,strLoadBalancerName, strMetric, strDataGranularity));
        }
        
        log.fine("[DEBUG] Result List Size: " + oResultList.size());
        
        // Save the results to DT
        saveResults(oResultList, env);
        
		return new Status(Status.StatusCode.Success);
	}

	@Override
	public void teardown(MonitorEnvironment env) throws Exception {
	}
	 
	//********************
	// PRIVATE METHODS
	//********************
	private GetMetricStatisticsResult getLBMetricResult(AmazonCloudWatch oClient, String strLoadBalancerName, String strMetricName, String strDataGranularity)
	{
		/*
		 * Calculate start and end time.
		 * This relies on the user-inputtable parameter.
		 * This MUST match the schedule for the plugin.
		 * eg. If the monitor runs every 10mins, the user MUST set this to be 10 mins.
		 * For possible values, see IConstants file.
		 */
		Date endTime = new Date();
		int dataGranularity = calculateDataGranularity(strDataGranularity);
		Date startTime = new Date(endTime.getTime() - dataGranularity); // Go back "dataGranularity" and pull data starting from then.
	
		// Build the AWS request. Get all aggregations for the selected metric and load balancer.
	    GetMetricStatisticsRequest oMetricRequest = new GetMetricStatisticsRequest()
	            .withStartTime(startTime)
	            .withNamespace(IConstants.AWS_NAMESPACE)
	            .withPeriod(dataGranularity)
	            .withDimensions(new Dimension().withName(IConstants.DIMENSION_NAME).withValue(strLoadBalancerName))
	            .withMetricName(strMetricName)
	            .withStatistics(m_oAggregationList)
	            .withEndTime(endTime);
	    
	    GetMetricStatisticsResult oResult = null;
	    
	    // Now actually go out to AWS and get the metrics. This can fail.
	    try
	    {
	    	oResult = oClient.getMetricStatistics(oMetricRequest);
	    }
	    catch (Exception e)
	    {
	    	log.severe("Error getting metrics from AWS. Returning null. " + e.getMessage());
	    }
	    
	    return oResult;
	}
	
	/*
	 * Calculate how far back in time we go to grab metrics. Users should ensure they make this match the
	 * monitor execution schedule.
	 * For example, if we run the monitor every 5 mins, this *must* be set to 5 mins.
	 * Otherwise you could run the monitor every 5 minutes and yet pull back the last hours statistics.
	 * This would lead to very strange results.
	 */
	private int calculateDataGranularity(String strDataGranularity)
	{
		if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1MIN))
		{
			log.finer("1min granularity");
			return 60 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_5MINS))
		{
			log.finer("5mins granularity");
			return 60 * 5 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_10MINS))
		{
			log.finer("10 mins granularity");
			return 60 * 10 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_15MINS))
		{
			log.finer("15 mins granularity");
			return 60 * 15 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_30MINS))
		{
			log.finer("30 mins granularity");
			return 60 * 30 * 1000;
		}
		else if (strDataGranularity.equals(IConstants.DATA_GRANULARITY_1HOUR))
		{
			log.finer("1 hour granularity");
			return 60 * 60 * 1000;
		}
		else
		{
			log.info("Got a strange data granularity. This should never happen. Return 60.");
			return 60;
		}
	}
	
	private void saveResults(List<GetMetricStatisticsResult> oResultList, MonitorEnvironment oEnvironment)
	{
		// For each potentially subscribed measure, get the actual measure from the environment
		for (String strMeasureName : m_oLBMetrics)
		{
			Collection<MonitorMeasure> monitorMeasures = oEnvironment.getMonitorMeasures(IConstants.MEASURE_GROUP_NAME, strMeasureName);
			log.fine("Monitor measures size for: " + strMeasureName + " - " + monitorMeasures.size()); // Should always be 1.
			
			for (MonitorMeasure subscribedMonitorMeasure : monitorMeasures)
			{
				List<Datapoint> oResultDatapoints = getResultMetricDatapoints(strMeasureName, oResultList);
				
				log.fine("oResultDatapoints Size: " + oResultDatapoints.size()); // Need to make sure this is always 1.
				
				// For each target aggregation, push the data into DT
				for (String strAggregation : m_oAggregationList)
				{
					MonitorMeasure oDynamicMeasure = oEnvironment.createDynamicMeasure(subscribedMonitorMeasure, "Aggregation", strAggregation);
					
					if (strAggregation.equals(IConstants.AGGREGATION_MINIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMinimum();
							
							log.finer("Setting value for MIN: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_AVERAGE))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getAverage();
							
							log.finer("Setting value for AVG: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_MAXIMUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getMaximum();
							
							log.finer("Setting value for MAX: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SUM))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSum();
							
							log.finer("Setting value for SUM: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else if (strAggregation.equals(IConstants.AGGREGATION_SAMPLE_COUNT))
					{
						// Need to make sure this only ever contains one datapoint.... Aggregation settings?
						for (Datapoint oDP : oResultDatapoints)
						{
							// AWS returns -1 in case of no data. Only push metrics to DT if data is valid.
							double dValue = oDP.getSampleCount();
							
							log.finer("Setting value for SAMPLE COUNT: " + dValue);
							
							if (dValue >= 0) oDynamicMeasure.setValue(dValue);
						}
					}
					else
					{
						log.info("Found something else.. Should never happen");
					}	
				} // End for each aggregation list.
			} // End for each monitor.
		} // End for each measure name.
	}
		
	/*  Helper Method 
	 *  Find the AWS GetMetricStatisticsResult which matches the input String
	 *  and return its datapoints.
	 *  eg. datapoints which matches "RequestCount"
	 */
	private List<Datapoint> getResultMetricDatapoints(String strMeasureName, List<GetMetricStatisticsResult> oResultList)
	{
		for (GetMetricStatisticsResult oTmpResult : oResultList)
		{
			if (oTmpResult.getLabel().equals(strMeasureName)) return oTmpResult.getDatapoints();
		}
		
		return new ArrayList<Datapoint>();
	}
}
